**Бинарные деревья поиска**

Бинарное дерево поиска – это двоичное дерево, для которого выполняются следующие свойства:

1. левое поддерево корня содержит вершины с ключами, меньшими ключа корня;
2. правое поддерево корня содержит вершины с ключами, большими ключа вершины;
3. левое и правое поддерево должны быть бинарными деревьями поиска.

АВЛ-дерево – сбалансированное по высоте бинарное дерево поиска: для каждой его вершины высота 
её двух поддеревьев различается не более чем на 1.

Тема "бинарные деревья поиска" является подготовкой к одной из самых сложных тем – "декартово дерево".
Поэтому особенно важно целиком и полностью разобрать с этой темой и выбрать удобный для вас способ хранения.

Немного об удобствах хранения. 
Я пишу на обычных указателях, испозуя обычную структуру. 
Обращу внимание, что тут не нужно следить за утечками памяти и подобном в силу реализации.
Вот структура, которую я использую в решении задач.

```binary
struct Node {
    int value;
    Node *left, *right;

    Node() = default;

    Node(int x) : value(x), left(nullptr), right(nullptr) {}
};
```

Добавление значения в бинарное дерево поиска происходит тривиально. 
Сначала мы спускаемся по дереву и ищем место для новой вершины с нашим значением. 
Вспоминаем про свойства бинарного дерева и, исходя из них, определяем в какого ребенка текущей вершины нам пойти – в левого или правого.
Как только мы добрались до несуществующей вершины, создаем новую с нашим значением.

```binary
void addNode(int x, Node *&root) {
    if (root == nullptr) {
        root = new Node(x);
        return;
    }
    if (root->value == x) {
        return;
    }
    if (root->value > x) {
        addNode(x, root->left);
    } else if (root->value < x) {
        addNode(x, root->right);
    }
}
```

В файле `main.cpp` представлено решение первой задачи из домашнего задания по данной теме.